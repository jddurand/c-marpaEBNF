#include "marpaEBNF.h"
#include "genericLogger.h"

static char *ebnfs = 
"(* vim: set ft=ebnf: *)" "\n"
"(*" "\n"
"  The syntax of Extended BNF can be defined using" "\n"
"  itself. There are four parts in this example," "\n"
"  the first part names the characters, the second" "\n"
"  part defines the removal of unnecessary non-" "\n"
"  printing characters, the third part defines the" "\n"
"  removal of textual comments, and the final part" "\n"
"  defines the structure of Extended BNF itself." "\n"
"" "\n"
"  Each syntax rule in this example starts with a" "\n"
"  comment that identifies the corresponding clause" "\n"
"  in the standard." "\n"
"" "\n"
"  The meaning of special-sequences is not defined" "\n"
"  in the standard. In this example (see the" "\n"
"  reference to 7.6) they represent control" "\n"
"  functions defined by ISO/IEC 6429:1992." "\n"
"  Another special-sequence defines a" "\n"
"  syntactic-exception (see the reference to 4.7)." "\n"
"*)" "\n"
"" "\n"
"(*" "\n"
"  The first part of the lexical syntax defines the" "\n"
"  characters in the 7-bit character set (ISO/IEC" "\n"
"  646:1991) that represent each terminal-character" "\n"
"  and gap-separator in Extended BNF." "\n"
"*)" "\n"
"" "\n"
"(* see 7.2 *) letter" "\n"
"= 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h'" "\n"
"| 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p'" "\n"
"| 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x'" "\n"
"| 'y' | 'z'" "\n"
"| 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H'" "\n"
"| 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P'" "\n"
"| 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X'" "\n"
"| 'Y' | 'Z';" "\n"
"(* see 7.2 *) decimal digit" "\n"
"= '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7'" "\n"
"| '8' | '9';" "\n"
"" "\n"
"(*" "\n"
"  The representation of the following" "\n"
"  terminal-characters is defined in clauses 7.3," "\n"
"  7.4 and tables 1, 2." "\n"
"*)" "\n"
"" "\n"
"concatenate symbol = ',';" "\n"
"defining symbol = '=';" "\n"
"definition separator symbol = '|' | '/' | '!';" "\n"
"end comment symbol = '*)';" "\n"
"end group symbol = ')';" "\n"
"end option symbol = ']' | '/)';" "\n"
"end repeat symbol = '}' | ':)';" "\n"
"except symbol = '-';" "\n"
"first quote symbol = \"'\";" "\n"
"repetition symbol = '*';" "\n"
"second quote symbol = '\"';" "\n"
"special sequence symbol = '?';" "\n"
"start comment symbol = '(*';" "\n"
"start group symbol = '(';" "\n"
"start option symbol = '[' | '(/';" "\n"
"start repeat symbol = '{' | '(:';" "\n"
"terminator symbol = ';' | '.';" "\n"
"(* see 7.5 *) other character" "\n"
"= ' ' | ':' | '+' | '_' | '%' | 'Q'" "\n"
"| '&' | '#' | '$' | '<' | '>' | '\\'" "\n"
"| '^' | \"'\" | '~';" "\n"
"(* see 7.6 *) space character = ' ';" "\n"
"horizontal tabulation character" "\n"
"= ? ISO 6429 character Horizontal Tabulation ? ;" "\n"
"new line" "\n"
"= { ? ISO 6429 character Carriage Return ? }," "\n"
"? ISO 6429 character Line Feed ?," "\n"
"{ ? ISO 6429 character Carriage Return ? };" "\n"
"vertical tabulation character" "\n"
"= ? ISO 6429 character Vertical Tabulation ? ;" "\n"
"form feed" "\n"
"= ? ISO 6429 character Form Feed ? ;" "\n"
"" "\n"
"(*" "\n"
"  The second part of the syntax defines the" "\n"
"  removal of unnecessary non-printing characters" "\n"
"  from a syntax." "\n"
"*)" "\n"
"" "\n"
"(* see 6.2 *) terminal character" "\n"
"= letter" "\n"
"| decimal digit" "\n"
"| concatenate symbol" "\n"
"| defining symbol" "\n"
"| definition separator symbol" "\n"
"| end comment symbol" "\n"
"| end group symbol" "\n"
"| end option symbol" "\n"
"| end repeat symbol" "\n"
"| except symbol" "\n"
"| first quote symbol" "\n"
"| repetition symbol" "\n"
"| second quote symbol" "\n"
"| special sequence symbol" "\n"
"| start comment symbol" "\n"
"| start group symbol" "\n"
"| start option symbol" "\n"
"| start repeat symbol" "\n"
"| terminator symbol" "\n"
"| other character;" "\n"
"(* see 6.3 *) gap free symbol" "\n"
"= terminal character" "\n"
"- (first quote symbol | second quote symbol)" "\n"
"| terminal string;" "\n"
"(* see 4.16 *) terminal string" "\n"
"= first quote symbol, first terminal character," "\n"
"{first terminal character}," "\n"
"first quote symbol" "\n"
"| second quote symbol, second terminal character," "\n"
"{second terminal character}," "\n"
"second quote symbol;" "\n"
"(* see 4.17 *) first terminal character" "\n"
"= terminal character - first quote symbol;" "\n"
"(* see 4.18 *) second terminal character" "\n"
"= terminal character - second quote symbol;" "\n"
"(* see 6.4 *) gap separator" "\n"
"= space character" "\n"
"| horizontal tabulation character" "\n"
"| new line" "\n"
"| vertical tabulation character" "\n"
"| form feed;" "\n"
"(* see 6.5 *) syntax" "\n"
"= {gap separator}," "\n"
"gap free symbol, {gap separator}," "\n"
"{gap free symbol, {gap separator}};" "\n"
"" "\n"
"(*" "\n"
"  The third part of the syntax defines the" "\n"
"  removal of bracketed-textual-comments from" "\n"
"  gap-free-symbols that form a syntax." "\n"
"*)" "\n"
"" "\n"
"(* see 6.6 *) commentless symbol" "\n"
"= terminal character" "\n"
"- (letter" "\n"
"| decimal digit" "\n"
"| first quote symbol" "\n"
"| second quote symbol" "\n"
"| start comment symbol" "\n"
"| end comment symbol" "\n"
"| special sequence symbol" "\n"
"| other character)" "\n"
"| meta identifier" "\n"
"| integer" "\n"
"| terminal string" "\n"
"| special sequence;" "\n"
"(* see 4.9 *) integer" "\n"
"= decimal digit, {decimal digit};" "\n"
"(* see 4.14 *) meta identifier" "\n"
"= letter, {meta identifier character};" "\n"
"(* see 4.15 *) meta identifier character" "\n"
"= letter" "\n"
"| decimal digit;" "\n"
"(* see 4.19 *) special sequence" "\n"
"= special sequence symbol," "\n"
"{special sequence character}," "\n"
"special sequence symbol;" "\n"
"(* see 4.20 *) special sequence character" "\n"
"= terminal character - special sequence symbol;" "\n"
"(* see 6.7 *) comment symbol" "\n"
"= bracketed textual comment" "\n"
"| other character" "\n"
"| commentless symbol;" "\n"
"(* see 6.8 *) bracketed textual comment" "\n"
"= start comment symbol, {comment symbol}," "\n"
"end comment symbol;" "\n"
"(* see 6.9 *) syntax" "\n"
"= {bracketed textual comment}," "\n"
"commentless symbol," "\n"
"{bracketed textual comment}," "\n"
"{commentless symbol," "\n"
"{bracketed textual comment}};" "\n"
"" "\n"
"(*" "\n"
"  The final part of the syntax defines the" "\n"
"  abstract syntax of Extended BNF, i.e. the" "\n"
"  structure in terms of the commentless symbols." "\n"
"*)" "\n"
"" "\n"
"(* see 4.2 *) syntax" "\n"
"= syntax rule, {syntax rule};" "\n"
"(* see 4.3 *) syntax rule" "\n"
"= meta identifier, defining symbol," "\n"
"definitions list, terminator symbol;" "\n"
"(* see 4.4 *) definitions list" "\n"
"= single definition," "\n"
"{definition separator symbol," "\n"
"single definition};" "\n"
"(* see 4.5 *) single definition" "\n"
"= syntactic term," "\n"
"{concatenate symbol, syntactic term};" "\n"
"(* see 4.6 *) syntactic term" "\n"
"= syntactic factor," "\n"
"[except symbol, syntactic exception];" "\n"
"(* see 4.7 *) syntactic exception" "\n"
"= ? a syntactic-factor that could be replaced" "\n"
"by a syntactic-factor containing no" "\n"
"meta-identifiers" "\n"
"? ;" "\n"
"(* see 4.8 *) syntactic factor" "\n"
"= [integer, repetition symbol]," "\n"
"syntactic primary;" "\n"
"(* see 4.10 *) syntactic primary" "\n"
"= optional sequence" "\n"
"| repeated sequence" "\n"
"| grouped sequence" "\n"
"| meta identifier" "\n"
"| terminal string" "\n"
"| special sequence" "\n"
"| empty sequence;" "\n"
"(* see 4.11 *) optional sequence" "\n"
"= start option symbol, definitions list," "\n"
"end option symbol;" "\n"
"(* see 4.12 *) repeated sequence" "\n"
"= start repeat symbol, definitions list," "\n"
"end repeat symbol;" "\n"
"(* see 4.13 *) grouped sequence" "\n"
"= start group symbol, definitions list," "\n"
"end group symbol;" "\n"
  ;

int main(int argc, char **argv) {
  int rci = 0;
  genericLogger_t  *genericLoggerp = GENERICLOGGER_NEW(GENERICLOGGER_LOGLEVEL_INFO);
  marpaEBNFOption_t marpaEBNFOption = { genericLoggerp };
  marpaEBNF_t *marpaEBNFp;

  marpaEBNFp = marpaEBNF_newp(&marpaEBNFOption);
  if (marpaEBNFp == NULL) {
    rci = 1;
    goto end;
  }

  GENERICLOGGER_INFO(genericLoggerp, "Parsing EBNF grammar using EBNF itself");
  GENERICLOGGER_INFOF(genericLoggerp, "%s", ebnfs);
  /* Use EBNF to parse itself */
  if (marpaEBNF_grammarb(marpaEBNFp, ebnfs) == 0) {
    rci = 1;
    goto end;
  }

 end:
  if (marpaEBNFp != NULL) {
    marpaEBNF_freev(marpaEBNFp);
  }

  GENERICLOGGER_FREE(genericLoggerp);

  return(rci);
}
